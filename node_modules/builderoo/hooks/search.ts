import {useContext, useEffect, useRef, useState} from "react";
import {Collection, Article, Pageable, ProductListItem} from "../types";
import api from "../api";
import {PageSpecificModelDataContext} from "../context";
import {useRouter} from "next/router";

type SearchType = "product" | "collection" | "page" | "post"

export type SearchProps = {
  types: SearchType[]
}

export type SearchResult = {
  products: ProductListItem[]
  collections: Collection[]
  articles: Article[]
  pages: Pageable[]
}

const initialState: SearchResult = {
  products: [],
  collections: [],
  articles: [],
  pages: []
}

type Choice = {
  name: string
  selected: boolean
}

type Filter = {
  name: string
  type: "variant" | "meta" | "tag" | "product"
  choices: Choice[]
}

export type MainSearchResult = {
  results: SearchResult
  filters: Filter[],
  query: string
}

export function usePredictiveSearch({types}: SearchProps){
  const [query, setQuery] = useState("")
  const [loading, setLoading] = useState<boolean>(false)
  const [results, setResults] = useState<SearchResult>(initialState)
  const timerRef = useRef<any>()

  useEffect(() => {
    if (!query){
      setLoading(false)
      return
    }
    setLoading(true)
    if (timerRef.current){
      clearTimeout(timerRef.current)
    }
    const timer = setTimeout(() => {
      api.post("/api/search/predictive", {
        q: query,
        types,
      }).then((response) => {
        setResults(response.data.results)
      }).catch(() => {
        setLoading(false)
      })
    }, 300)
    timerRef.current = timer
    return () => clearTimeout(timer)
  }, [query])

  return {
    loading,
    results,
    query,
    setQuery
  }
}

export function useSearch() {
  const [loading, setLoading] = useState<boolean>(false)
  const router = useRouter()
  const searchResult: MainSearchResult = useContext(PageSpecificModelDataContext).search
  const [query, setQuery] = useState(searchResult.query)
  const [filters, setFilters] = useState(searchResult.filters)


  useEffect(() => {
    setFilters(searchResult.filters)
  }, [searchResult]);

  useEffect(() => {
    const handleStart = (targetUrl: string) => {
      const source = new URL(router.asPath, "https://r")
      const target = new URL(targetUrl, "https://r")

      if (source.pathname == target.pathname){
        const sourcePage = source.searchParams.get("q")
        const targetPage = target.searchParams.get("q")
        if (sourcePage != targetPage){
          setLoading(true)
        }
      }
    };

    const handleStop = () => {
      setLoading(false)
    };

    router.events.on("routeChangeStart", handleStart);
    router.events.on("routeChangeComplete", handleStop);
    router.events.on("routeChangeError", handleStop);

    return () => {
      router.events.off("routeChangeStart", handleStart);
      router.events.off("routeChangeComplete", handleStop);
      router.events.off("routeChangeError", handleStop);
    };
  }, [router]);

  const _searchAgain = (filters: Filter[]) => {
    const url = new URL(router.asPath, "https://r")
    const params: {[key: string]: string[]} = {}
    for(let filter of filters){
      const selectedValues = filter.choices.filter(choice => choice.selected).map(choice => choice.name.toLowerCase())
      const key = `filter[${ filter.type == "variant" || filter.type == "meta" ? `${filter.type}.` : ""}${filter.name.toLowerCase()}]`
      if (selectedValues.length){
        params[key] = selectedValues
        for (let i= 0; i < selectedValues.length; i++){
          if (i == 0){
            url.searchParams.set(key, selectedValues[i])
          } else {
            url.searchParams.append(key, selectedValues[i])
          }
        }
      } else {
        delete params[key]
        delete router.query[key]
        url.searchParams.delete(key)
      }
    }
    if (query){
      url.searchParams.set("q", query)
      params["q"] = query as any
    }
    console.log(url.search)
    return router.push({
      pathname: router.pathname,
      query: {
        route: url.pathname,
        ...router.query,
        ...params,
      },
    }, `${url.pathname}${decodeURIComponent(url.search)}`)

  }

  const searchAgain = () => {
    return _searchAgain(filters)
  }

  const toggleFilter = (name: string, type: string | undefined, choice: string, apply: boolean = true) => {
    const newFilters = filters.map(filter => {
      if (filter.name == name && filter.type == type){
        const choices = filter.choices.map(_choice => {
          if (_choice.name == choice){
            return {..._choice, selected: !_choice.selected}
          }
          return _choice
        })
        return {...filter, choices}
      }
      return filter
    })
    setFilters(newFilters)
    if (apply){
      _searchAgain(newFilters)
    }
  }

  return {
    loading,
    results: searchResult.results,
    filters,
    query,
    setQuery,
    searchAgain,
    toggleFilter
  }

}