import {useState, useMemo, useCallback} from "react";
import {Media, Product, Variant} from "../types";
import {NextRouter, useRouter} from "next/router";


function getSelectedVariant(product: Partial<Product>, selectedOptionsMap: Record<string, string>){
  // if (!product.hasVariants) return null
  if (!product.variants || product.variants.length < 1) return null
  // matching 2 of arrays of same values in different order
  const selected = Object.values(selectedOptionsMap).sort().join('-')
  const length = Object.values(selectedOptionsMap).length
  for (let variant of product.variants){
    if (variant.values.length === length && selected === variant.values.sort().join('-')){
      return variant
    }
  }
  return null
}


function getInitialVariantOptionsMap(product: Partial<Product>, router: NextRouter, variant?: Variant | string){
  if (!product.options || product.options.length < 1) return {}

  if (router.query.variant){
    variant = router.query.variant as string
  }
  const _variant = typeof variant == "string" ? product.variants?.find(item => item._id === variant) : variant
  if (!_variant){
    return {}
  }
  const optionsMap: Record<string, string> = {}
  for (let option of product.options){
    for (let value of option.values){
      if (_variant.values.indexOf(value._id) >= 0){
        optionsMap[option._id] = value._id
      }
    }
  }
  return optionsMap
}

function findMediaWithMostMatches(selectedOptionValues: string[], mediaItems?: Media[], ): Media | null {
  if (!mediaItems || mediaItems.length < 1){
    return null
  }
  let maxMatches = 0;
  let mediaWithMostMatches: Media | null = null;

  for (const mediaItem of mediaItems) {
    if (!mediaItem.relatedOptions) {
      continue
    }
    const matches = mediaItem.relatedOptions.filter(value => selectedOptionValues.includes(value)).length;
    if (matches > maxMatches) {
      maxMatches = matches;
      mediaWithMostMatches = mediaItem;
    }
  }
  return mediaWithMostMatches;
}

/***
 *
 * @param product
 * @param initialSelectedVariant
 * the one comprising this map
 */
export function useSelectedVariant(product: Partial<Product>, initialSelectedVariant?: Variant | string) {
  const router = useRouter()
  const initialOptionsMap = useMemo(() => getInitialVariantOptionsMap(product, router, initialSelectedVariant), [product, initialSelectedVariant, router])
  const [selectedOptions, setSelectedOptions] = useState(initialOptionsMap)
  const [variant, setVariant] = useState(getSelectedVariant(product, initialOptionsMap))
  const [preferredMedia, setPreferredMedia] = useState(product.media && product.media.length > 0 ? product.media[0] : null)

  const onSelectOption = useCallback((optionId: string, valueId: string) => {
    const selectedOption = product.options?.find(o => o._id == optionId)
    if (selectedOption && selectedOption.type == "product"){
      const value = selectedOption.values.find(v => v._id == valueId)
      if (value){
        // @ts-ignore
        const {template, route} = value
        return router.push({
          pathname: template,
          query: {route, template}
        }, route)
      }
      return
    }
    const options = {...selectedOptions, [optionId]: valueId}
    setSelectedOptions(options);
    setVariant(getSelectedVariant(product, options))
    setPreferredMedia(findMediaWithMostMatches(Object.values(options), product.media))
  }, [selectedOptions])

  const isOptionSelected = useCallback((optionId: string, valueId: string) => {
    const selectedOption = product.options?.find(o => o._id == optionId)
    if (selectedOption && selectedOption.type == "product"){
      const value = selectedOption.values.find(v => v._id == valueId)
      return (value as any)?.product == product._id
    }
    return Object.values(selectedOptions).indexOf(valueId) >= 0
  }, [selectedOptions])

  return {
    variant,
    selectedOptions,
    preferredMedia,
    setPreferredMedia,
    onSelectOption,
    isOptionSelected
  }
}
