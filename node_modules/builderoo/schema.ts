import type {Product, Collection, Article} from "./types"

// Start of copy to build.theme.js
const kValues = Symbol.for("kValues")

class Prop {

  [kValues]: any = {}

  protected constructor(type: string, def?: any) {
    this[kValues]["type"] = type
    this.default(def)
  }

  protected _ = (prop: string, value: any) => {
    this[kValues][prop] = value
    return this
  }

  // types
  static number = () => new _NumberProp("number", 0)
  static text = () => new Prop("text", "")
  static image = () => new Prop("image", null)
  static product = () => new _ProductProp("product", null)
  static collection = () => new _CollectionProp("collection", null)
  static article = () => new _ArticleProp("article", null)
  static url = () => new Prop("url", null)
  static range = (min: number, max: number, step: number) => new _RangeProp("range", min, max, step)
  static boolean = () => new _BooleanProp("bool", false)
  static choice = () => new _ChoiceProp("choice")
  static color = () => new Prop("color", null)

  static meta = () => new _MetaProp()

  // properties
  label = (val: string) => this._("label", val)
  hint = (val: string) => this._("hint", val)
  default = (val: any) => this._("default", val)
}

function _convertToArray(arrayClass: any, obj: Prop, type: string){
  const a = new arrayClass()
  a[kValues] = obj[kValues]
  a[kValues]["type"] = type
  a[kValues]["default"] = []
  return a
}

class _ArrayProp extends Prop {
  max = (val: number) => this._("max", val)
  min = (val: number) => this._("min", val)
}

class _MetaProp extends Prop {
  constructor() {
    super("_meta_")
  }
  max = (val: number) => this._("max", val)
  min = (val: number) => this._("min", val)
}

class _NumberProp extends Prop {
  private ["number"] = 0
  max = (val: number) => this._("max", val)
  min = (val: number) => this._("min", val)
}

class _ProductArrayProp extends _ArrayProp {
  private ["product[]"] = 0
}

class _ProductProp extends Prop {
  array = (): _ProductArrayProp => _convertToArray(_ProductArrayProp, this, "product[]")
}

class _CollectionArrayProp extends _ArrayProp {
  private ["collection[]"] = 0
}

class _CollectionProp extends Prop {
  array = (): _CollectionArrayProp => _convertToArray(_CollectionArrayProp, this, "collection[]")
}

class _PostArrayProp extends _ArrayProp {
  private ["post[]"] = 0
}

class _ArticleProp extends Prop {
  array = (): _PostArrayProp => _convertToArray(_PostArrayProp, this, "post[]")
}

class _BooleanProp extends Prop {
  private ["boolean"] = 0
}

class _RangeProp extends Prop {
  private ["range"] = 0
  constructor(type: string, min: number, max: number, step: number) {
    super(type)
    this[kValues]["min"] = min
    this[kValues]["max"] = max
    this[kValues]["step"] = step
  }
}

class _ChoiceProp extends Prop {
  option = (value: string, label?: string): this => {
    if (!this[kValues]["options"]){
      this[kValues]["options"] = []
    }
    this[kValues]["options"] = [...this[kValues]["options"], {value, label}]
    return this
  }
}

// end of copy build.theme.js

// not exporting _CollectionProp creates this problem: TS4023
export {Prop, _CollectionProp}

export type Props<T> = {
  [K in keyof T]: T[K] extends _NumberProp ? number
    : T[K] extends _ProductProp ? Product
    : T[K] extends _ProductArrayProp ? Product[]
    : T[K] extends _CollectionProp ? Collection
    : T[K] extends _CollectionArrayProp ? Collection[]
    : T[K] extends _ArticleProp ? Article
    : T[K] extends _PostArrayProp ? Article[]
    : T[K] extends _RangeProp ? number
    : T[K] extends _BooleanProp ? boolean
    : string
}

type BlockObject<T> = {
  [K in keyof T]: {name: K, props: Omit<Props<T[K]>, "_meta_">, key: string}
}

export type Blocks<T> = BlockObject<T>[keyof T];

export type Config<T> = {
  [K in keyof T]: T[K] extends Prop ? Props<T>[K] : Omit<Props<T[K]>, "_meta_">
} & {
  productImageSizes: number[][]
}

export type InitialBlocks<T> = (keyof T | BlockObject<T>[keyof T])[]