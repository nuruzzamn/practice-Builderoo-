import updateSchemaWithPropsData, {getDataDefaultOrThrow, getDataValue} from "./prop.converter";
import {EditableSection} from "./components/Section";
import { GetServerSideProps } from 'next'
import dynamic from 'next/dynamic'
import {SectionDataContext, EditorContextInternal} from "./context";
import {Prop} from "./schema";
import {SectionBlock} from "./types";
import {PropsWithChildren, useMemo} from "react";
import getConfig from "next/config";


const { serverRuntimeConfig } = getConfig()
const kValues = Symbol.for("kValues")
const sleep = (waitTimeInMs: number) => new Promise(resolve => setTimeout(resolve, waitTimeInMs));

// @ts-ignore
if (!global.__localCache){
  // @ts-ignore
  global.__localCache = {user: null, cart: null}
}

// @ts-ignore
const cache = global.__localCache

function EmptyLayout({children}: PropsWithChildren){
  return (
    <>{children}</>
  )
}

function SectionWrapper({editor, children, section, index}: any){
  return !editor ? children : <EditableSection section={section} index={index}>{children}</EditableSection>
}

function LayoutWrapper({editor, children}: any){
  return !editor ? children : <EditorContextInternal.Provider value={{}}>{children}</EditorContextInternal.Provider>
}

function ActualPage({schema, editor}: any){
  const sectionsJsx = []
  for (let i=0; i < schema.sections.length; i++){
    const section = schema.sections[i]
    section.index = i
    const Component: any = useMemo(() => dynamic(() => import(`/sections/${section.component}`)), [section.component])
    sectionsJsx.push(
      <SectionWrapper editor={editor} section={section} index={i} key={section.key}>
        <SectionDataContext.Provider value={section} key={section.key}>
          <Component />
        </SectionDataContext.Provider>
      </SectionWrapper>
    )
  }
  const Layout: any = schema.layout?.component ? useMemo(() => dynamic(() => import(`/layouts/${schema.layout.component}`)), [schema.layout.component]) : EmptyLayout
  return (
    <LayoutWrapper editor={editor}>
      <Layout {...schema.layout?.props}>
        {sectionsJsx}
      </Layout>
    </LayoutWrapper>
  )
}

export function Page({schema, editor}: any){
  // the key prop below is important. This will reset the component. Otherwise, number of hooks will be different
  // between re-renders.
  const key = schema.layout?.component + schema.sections.reduce((a: string, c: any) => a + c.component, "")
  return (
    <ActualPage schema={schema} key={key} editor={editor} />
  )
}

// This is only for testing in development
export function EditorPage({schema}: any){
  return <Page schema={schema} editor={true} />
}

const return404 = ['favicon.ico']


function respondJson(res: any, ob: any, statusCode: number = 200){
  res.statusCode = statusCode
  res.setHeader("Content-Type", "application/json");
  res.write(typeof ob == "string" ? ob : JSON.stringify(ob));
  res.end();
  return {
    props: {}
  }
}

export function defaults(props: {[key: string]: Prop}){
  if (!props) return {}
  return Object.keys(props).reduce((a, c) => {
    if (c == "_meta_") return a
    // @ts-ignore
    a[c] = props[c][kValues]["default"] || null
    return a
  }, {} as any)
}

// "raw-body" package spams the console with a warning
async function parseJsonBody(req: any): Promise<any>{
  return new Promise((resolve) => {
    let data = '';
    req.on('data', (chunk: any) => data += chunk)
    req.on('end', () => resolve(JSON.parse(data)))
  })
}

function getSearchResults(types: string[], q: string){
  return {
    products: types.indexOf("product") >= 0 ? getDataValue("products", []).filter((p: any) => p.title.toLowerCase().includes(q.toLowerCase())) : [],
    collections: types.indexOf("collection") >= 0 ? getDataValue("collections", []).filter((p: any) => p.title.toLowerCase().includes(q.toLowerCase())) : [],
  }
}

function parseQuery(queryParams: any){
  const filters: {[key: string]: string | string[]} = {}
  for (const [param, value] of Object.entries(queryParams)) {
    const matches = param.match(/^filter\[variant\.(\w+)\]$|^filter\[meta\.(\w+)\]|^filter\[([\w.]+)\]$/)
    if (matches) {
      const variantKey = matches.length > 0 ? matches[1] : null
      const metaKey = matches.length > 1 ? matches[2] : null
      const productKey = matches.length > 2 ? matches[3] : null
      if (variantKey) {
        filters[`variant-${variantKey.toLowerCase()}`] = Array.isArray(value) ? value.map(item => item.toLowerCase()) : [(value as string).toLowerCase()]
      } else if (metaKey) {
        filters[`meta-${metaKey.toLowerCase()}`] = Array.isArray(value) ? value.map(item => item.toLowerCase()) : [(value as string).toLowerCase()]
      } else if (productKey) {
        if (productKey == "vendor" || productKey == "tag"){
          filters[`product-${productKey.toLowerCase()}`] = Array.isArray(value) ? value.map(item => item.toLowerCase()) : [(value as string).toLowerCase()]
        }
      }
    }
  }
  return filters
}


export const getServerSideProps: GetServerSideProps<any> = async (context) => {

  const isSSR = !!context.req.url && (context.req.url!.indexOf("/_next/data/") < 0)

  if (!context.query.dev && context.resolvedUrl != "/"){
    return {
      props: {

      }
    }
  }

  if (!isSSR){
    await sleep(serverRuntimeConfig.API_DELAY || 0)
  }

  let cart = cache.cart
  if (!cart){
    cart = getDataValue("cart", {items: []})
    cache.cart = cart
  }

  let page = Array.isArray(context.query.dev) ? (context.query.dev as string[]).join("/") : context.query.dev || "index"

  if (page == "favicon.ico"){
    return {notFound: true}
  }
  if (context.resolvedUrl == "/"){
    page = "index"
  } else if (page == "api/account/login"){
    const body = await parseJsonBody(context.req)
    const user = getDataDefaultOrThrow("user", "User data missing in \"data\" folder.")
    if (body.username != user.email || body.password != "123456"){
      return respondJson(context.res, {error: "invalid-username-or-password"}, 400)
    }
    cache["user"] = user
    // cookies.set("user", JSON.stringify(user), {httpOnly: true})
    return respondJson(context.res, {user}, 200)
  } else if (page == "api/account/logout"){
    cache["user"] = null
    // cookies.set("user", null)
    return respondJson(context.res, {}, 200)
  } else if (page == "api/account/signup"){
    const body = await parseJsonBody(context.req)
    const user = getDataDefaultOrThrow("user", "User data missing in \"data\" folder.")
    if (body.action == "verify"){
      if (body.code != "123456"){
        return respondJson(context.res, {error: "code-invalid-or-expired"}, 400)
      }
    } else if (body.action == "signup"){
      if (user.email != body.username){
        return respondJson(context.res, {error: "username-exists"}, 400)
      }
      if (body.password != "123456"){
        return respondJson(context.res, {status: "code-verification-required", token: "-------"}, 200)
      }
    }
    cache["user"] = user
    return respondJson(context.res, {user, status: "successful"}, 200)
  } else if (page == "api/account/password"){
    const body = await parseJsonBody(context.req)
    const user = getDataDefaultOrThrow("user", "User data missing in \"data\" folder.")
    if (body.action == "request-reset"){
      return respondJson(context.res, {}, 200)
    } else if (body.action == "reset"){
      if (body.code != "123456"){
        return respondJson(context.res, {error: "code-invalid-or-expired"}, 400)
      }
    } else if (body.action == "change"){
      if (body.oldPassword != "123456"){
        return respondJson(context.res, {error: "invalid-old-password"}, 400)
      }
    }
    cache["user"] = user
    return respondJson(context.res, {user}, 200)
  } else if (page == "api/cart"){
    const method = context.req.method
    if (method == "POST" || method == "DELETE" || method == "PATCH"){
      const {product, variant, quantity} = await parseJsonBody(context.req)
      const target = cart.items.findIndex((item: any) => item.product._id == product && item.variant._id == variant)
      if (target >= 0){
        if (method == "POST"){
          cart.items[target].quantity += parseInt(quantity)
        } else if (method == "DELETE"){
          cart.items.splice(target, 1)
        } else if (method == "PATCH"){
          cart.items[target].quantity = parseInt(quantity)
        }
      } else if (method == "POST"){
        const targetProduct = getDataValue("products", []).find((item: any) => item._id == product)
        if (targetProduct){
          cart.items.push({
            product: targetProduct,
            variant: targetProduct.variants.find((v: any) => v._id = variant),
            quantity: quantity
          })
        }
        // search all products and add to cart.
      }
    }
    return respondJson(context.res, cart, 200)
  } else if (page == "api/search/predictive"){
    const {q, types} = await parseJsonBody(context.req)
    return respondJson(context.res, {
      results: getSearchResults(types, q)
    })
  }

  try {
    delete require.cache[require.resolve(`/pages/${page}.json`)];
  } catch (e) {
    page = Array.isArray(context.query.dev) ? context.query.dev[0] : context.query.dev || "index"
    try {
      delete require.cache[require.resolve(`/pages/${page}.json`)];
    } catch (e) {
      if (page == "_next"){
        return {notFound: true}
      }
      const hasMultiParts = Array.isArray(context.query.dev) && context.query.dev.length > 1
      const path = hasMultiParts ? `"pages/${page}.json" or "pages/${(context.query.dev as string[]).join("/")}.json` : `"pages/${page}.json"`
      throw new Error(`Page json file not found at path: ${path}`)
    }
  }

  if (return404.indexOf(page) >= 0){
    return {
      notFound: true,
    }
  }

  let schema
  try {
    schema = require(`/pages/${page}.json`)
  } catch (e) {
    page = "404"
    delete require.cache[require.resolve(`/pages/${page}.json`)];
    try {
      schema = require(`/pages/${page}.json`)
    } catch (e){
      return {
        notFound: true
      }
    }
  }

  // Parse the config file and defaults
  let config: {[key: string]: any} = {}
  try {
    const configRequire = require('/theme.config.js')
    const configObject = configRequire.themeConfig
    config = Object.keys(configObject).reduce((a, c) => {
      if (c == "_meta_") return a
      if (configObject[c] instanceof Prop){
        a[c] = configObject[c][kValues]["default"] || null
      } else {
        a[c] = defaults(configObject[c])
      }
      return a
    }, {} as any)

    config.productImageSizes = configRequire.productImageSizes || []
  } catch (e) {

  }

  // apply default props from section schema
  const allComponents = await Promise.all(schema.sections.map((item: any) => import(`/sections/${item.component}`)))
  for(let [i, section] of schema.sections.entries()){
    section.key = section.component
    section.props = {...defaults(allComponents[i].props), ...section.props}

    const sectionBlockDefaults = Object.keys(allComponents[i].blocks || {}).reduce((a, c) => {
      a[c] = defaults(allComponents[i].blocks[c])
      return a
    }, {} as any)
    section.blocks = (section.blocks || []).map((item: SectionBlock, p: number) => {
      item.key = p.toString()
      item.props = {...sectionBlockDefaults[item.name], ...item.props}
      return item
    })
    if ((!section.blocks || section.blocks.length < 1) && allComponents[i].initialBlocks){
      section.blocks = allComponents[i].initialBlocks.map((item: any, i: number) => {
        return typeof item == "string" ? { name: item, props: sectionBlockDefaults[item], key: i.toString() } : item
      })
    }
  }

  updateSchemaWithPropsData(schema, allComponents)

  const modelPagePropValues: any = {}
  if (["product", "post", "collection", "page", "collections", "orders", "order"].indexOf(page) >= 0 && schema["dev:data"]){
    modelPagePropValues[page] = getDataValue(schema["dev:data"].substring(5))
  }

  if (page == "collection" || page == "search"){
    const products = getDataValue("products", [])
    const filters: any[] = []
    const selectedOptions = parseQuery(context.query)
    for(let product of products){
      for (let option of product.options){
        const op = filters.find(item => item.name.toLowerCase() == option.name.toLowerCase())
        const selected = selectedOptions[`variant-${option.name.toLowerCase()}`] || []
        if (op){
          const newValues = option.values.filter((v: any) => op.choices.findIndex((c: any) => v.label.toLowerCase() == c.name.toLowerCase()) < 0)
          op.choices.push(...newValues.map((v: any) => ({name: v.label, selected: selected.includes(v.label.toLowerCase())})))
        } else {
          filters.push({name: option.name, type: "variant", choices: option.values.map((v: any) => ({name: v.label, selected: selected.includes(v.label.toLowerCase())}))})
        }
      }
    }
    modelPagePropValues["search"] = {
      query: "",
      results: null,
      filters
    }
  }

  if (page == "search"){
    const q = context.query.q as string || ""
    modelPagePropValues["search"].query = q
    modelPagePropValues["search"].results = getSearchResults(["product", "collection"], q)
  }

  if (["collection", "collections", "orders", "search"].indexOf(page) >= 0){
    const url = new URL(context.req.url || "/", "https://r")
    const searchParams = url.searchParams
    modelPagePropValues["pageNumber"] = parseInt(searchParams.get("page") || "1")
    modelPagePropValues["itemsPerPage"] = parseInt(searchParams.get("limit") || "10")
    modelPagePropValues["itemsCount"] = parseInt(searchParams.get("total") || "105")
  }

  const menu = getDataValue("menu", {main: {}, footer: {}}, true)

  return {
    props: {
      schema,
      cart,
      user: cache["user"] || null,
      extraLinks: {},
      //__R_PAGE: page, // development only
      app: {
        isDevelopMode: true,
        publicAssetPrefix: "",
        config,
        menu: {
          main: menu.main,
          footer: menu.footer
        },
        captcha: {
          siteKey: "6LfG68YbAAAAAJZ_MTyRiB5HHrY3H-clCqSwE1Z6",
          altSiteKey: "6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI",
          provider: "recaptcha",
        },
        locale: {
          country: {
            code: "US",
            name: "United States",
          },
          currency: {
            code: "USD",
            name: "US Dollar",
            symbol: "$",
            decimals: 2,
            display: "symbol",
            grouping: "min2"
          },
          language: {
            code: "English",
            name: "en",
          }
        },
      },
      ...modelPagePropValues
    }
  }
}