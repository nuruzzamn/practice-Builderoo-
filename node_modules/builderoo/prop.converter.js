import {DYNAMIC_FIELDS} from "./constants";
const kValues = Symbol.for("kValues")

export function getDataDefaultOrThrow(suffix, error){
  try {
    return require(`/data/${suffix}`).default
  } catch (e){
    throw new Error(error)
  }
}

export function getDataValue(ref, defaultData, clearCache = false){
  const [file, index] = ref.split(":")
  if (clearCache){
    try {
      delete require.cache[require.resolve(`/data/${file}`)];
    } catch (e) {

    }
  }
  try {
    const data = require(`/data/${file}`).default
    return index ? data[index] : data
  } catch (e){
    console.error(`Error loading data file: ${file}`, e)
    return defaultData || null
  }
}

function convertProps(parent, prop, value, propSchema){
  if (prop.startsWith("dev:")){
    delete parent[prop]
    prop = prop.substring(4)
    parent[prop] = value
  }

  if (!value){
    // pass
  } else if (Array.isArray(value)){
    for (let i in value){
      if (value[i].startsWith("data:")){
        if (!propSchema || !propSchema[prop]) throw new Error("Schema must be defined before using `data:` as prop value")
        if (DYNAMIC_FIELDS.indexOf(propSchema[prop][kValues].type) < 0) throw new Error(`Only props of types ${DYNAMIC_FIELDS.join(", ")} can have data: as value`)
        value[i] = getDataValue(value[i].substring(5)) || null
      }
    }
  } else if (value.startsWith("data:")) {
    if (!propSchema || !propSchema[prop]) throw new Error("Schema must be defined before using `data:` as prop value")
    if (DYNAMIC_FIELDS.indexOf(propSchema[prop][kValues].type) < 0) throw new Error(`Only props of types ${DYNAMIC_FIELDS.join(", ")} can have data: as value`)
    parent[prop] = getDataValue(value.substring(5)) || null
  }
}

export default function updateSchemaWithPropsData(schema, sectionSchemas){
  for (let i in schema.sections){
    const section = schema.sections[i]
    for (let [prop, value] of Object.entries(section.props || {})){
      convertProps(section.props, prop, value, sectionSchemas[i].props);
    }
    const blocks = section.blocks || []
    for (let block of blocks){
      const blockSchema = sectionSchemas[i].blocks ? sectionSchemas[i].blocks[block.name] : null
      for (let [prop, value] of Object.entries(block.props || {})){
        convertProps(block.props, prop, value, blockSchema ? blockSchema : null);
      }
    }
  }
}
